---
phase: 04-session-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - agent-session
autonomous: true

must_haves:
  truths:
    - "Running `agent-session` without subcommand shows help"
    - "Running `agent-session start` creates/attaches to session (existing behavior)"
    - "Running `agent-session stop NAME` stops a running session"
    - "Running `agent-session restart NAME` starts stopped container and reattaches"
    - "Stopping already-stopped session succeeds silently (idempotent)"
    - "Restarting already-running session attaches without error"
  artifacts:
    - path: "agent-session"
      provides: "Subcommand CLI dispatcher with stop and restart commands"
      contains: "case.*start\\)|case.*stop\\)|case.*restart\\)"
  key_links:
    - from: "cmd_stop()"
      to: "podman stop"
      via: "find_container helper"
      pattern: "podman stop"
    - from: "cmd_restart()"
      to: "attach_zellij()"
      via: "start then attach"
      pattern: "podman start.*attach_zellij"
---

<objective>
Refactor agent-session to subcommand structure and implement stop/restart commands.

Purpose: Transform single-purpose script into extensible CLI with lifecycle commands. Users can stop sessions cleanly and restart them without knowing podman commands.

Output: Updated agent-session script with subcommand dispatch, stop, and restart functionality.
</objective>

<execution_context>
@/home/owen/.claude/get-shit-done/workflows/execute-plan.md
@/home/owen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-session-management/04-CONTEXT.md
@.planning/phases/04-session-management/04-RESEARCH.md
@agent-session
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor to subcommand dispatch structure</name>
  <files>agent-session</files>
  <action>
Refactor agent-session to use subcommand dispatch pattern:

1. Create main() function with case statement dispatching on first argument:
   - start -> cmd_start "$@" (current behavior)
   - stop -> cmd_stop "$@"
   - restart -> cmd_restart "$@"
   - ls|list -> cmd_ls "$@"
   - rm|remove -> cmd_rm "$@"
   - -h|--help|help|"" -> show_help; exit 0
   - * -> error: unknown command, show hint

2. Wrap existing session creation logic in cmd_start() function:
   - Move everything after load_agent_config into cmd_start()
   - cmd_start() handles its own argument parsing (unchanged from current)
   - Keep AGENT_TYPE/AGENT_SPECIFIED/SESSION_NAME/PATHS parsing in cmd_start()

3. Add helper functions that other commands will share:
   - resolve_session_name() - returns arg if provided, else basename of pwd
   - find_container() - searches for container matching session name across all agent types
   - get_agent_types() - returns list of available agents from config/agents/

4. Update show_help() to document subcommand structure:
   - Show usage as: agent-session <command> [options]
   - List commands: start, stop, restart, ls, rm
   - Show examples for each command
   - Keep existing environment variable documentation

5. Define color constants at top of script:
   - COLOR_GREEN='\033[0;32m'
   - COLOR_RED='\033[0;31m'
   - COLOR_RESET='\033[0m'

Key patterns from RESEARCH.md:
- Use shift after case match to pass remaining args
- resolve_session_name defaults to $(basename "$(pwd)")
- find_container uses grep -E "^(agent1|agent2)-name$" pattern

Do NOT implement cmd_stop, cmd_restart, cmd_ls, cmd_rm yet - just declare them as stubs that echo "Not implemented: $0" for now. Task 2 and Task 3 will implement them.
  </action>
  <verify>
Run these commands and verify expected output:
- `./agent-session` shows help (no default to start)
- `./agent-session --help` shows help with subcommand documentation
- `./agent-session start --help` shows start subcommand options
- `./agent-session unknown` shows "unknown command" error with hint
  </verify>
  <done>
Script restructured with subcommand dispatch. Running without args shows help. cmd_start preserves all existing functionality. Helper functions exist for session resolution and container finding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement stop command</name>
  <files>agent-session</files>
  <action>
Implement cmd_stop() function:

1. Parse arguments:
   - First positional arg is session name (optional)
   - No flags needed (stop does not prompt per CONTEXT.md)

2. Resolve session name:
   - Use resolve_session_name() helper
   - If no arg, default to current directory basename

3. Find container:
   - Use find_container() helper
   - If not found, error: "Session 'NAME' not found. Use 'agent-session ls' to see sessions." and exit 1

4. Stop container:
   - Run: podman stop "$container" >/dev/null 2>&1 || true
   - The || true ensures idempotent behavior (already-stopped succeeds)
   - Output: "Stopped: $session_name"

CONTEXT.md decisions to honor:
- Stop does not prompt (reversible via restart)
- Stopping already-stopped session: silent success (idempotent)
- Action feedback: echo what happened
  </action>
  <verify>
Test stop command:
1. Start a test session: `./agent-session start -n test-stop ~/projects/agent-session`
2. Detach from session (Ctrl+B D or close terminal)
3. Stop it: `./agent-session stop test-stop`
4. Verify output shows "Stopped: test-stop"
5. Run stop again: `./agent-session stop test-stop`
6. Verify idempotent (no error, silent success or same message)
7. Verify container stopped: `podman ps -a --filter name=test-stop`
  </verify>
  <done>
cmd_stop() implemented. Running `agent-session stop NAME` stops container. Stopping already-stopped session succeeds silently. Clear feedback on stop action.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement restart command</name>
  <files>agent-session</files>
  <action>
Implement cmd_restart() function:

1. Parse arguments:
   - First positional arg is session name (optional)

2. Resolve session name and find container (same as stop)

3. Check if already running:
   - Use: podman ps --format "{{.Names}}" | grep -q "^${container}$"
   - If running: echo "Session 'NAME' is already running. Attaching..."
   - If not running: echo "Starting 'NAME'..."; podman start "$container" >/dev/null; sleep 1

4. Reattach to Zellij:
   - Extract AGENT_TYPE from container name (it's the prefix before first hyphen)
   - Load agent config to get AGENT_SHELL and AGENT_LAUNCH_CMD variables
   - Set CONTAINER_NAME and SESSION_NAME variables that attach_zellij() uses
   - Call attach_zellij()

Key insight from RESEARCH.md pitfall #3:
- podman start alone doesn't reattach terminal
- Must call attach_zellij() after start to reconnect to Zellij session
- Zellij session inside container survives stop/start (process state lost but session name persists)

Extract agent type from container name:
- Container name format: ${AGENT_TYPE}-${SESSION_NAME}
- agent_type="${container%%-*}" extracts prefix before first hyphen
  </action>
  <verify>
Test restart command:
1. Ensure test-stop session exists and is stopped from Task 2
2. Restart it: `./agent-session restart test-stop`
3. Verify output shows "Starting 'test-stop'..."
4. Verify you're attached to Zellij session
5. Detach (Ctrl+B D)
6. Run restart again while running: `./agent-session restart test-stop`
7. Verify output shows "already running. Attaching..." and connects
8. Clean up: stop and remove test session
  </verify>
  <done>
cmd_restart() implemented. Running `agent-session restart NAME` starts stopped container and reattaches to Zellij. Already-running sessions attach without error.
  </done>
</task>

</tasks>

<verification>
All tests pass:
- `./agent-session` shows help with subcommand docs
- `./agent-session start -n test ~/path` creates session (existing behavior preserved)
- `./agent-session stop test` stops the session
- `./agent-session restart test` starts and reattaches
- Idempotent operations work (stop stopped, restart running)
- Error messages include helpful hints
</verification>

<success_criteria>
1. Subcommand dispatch pattern implemented
2. cmd_start() preserves all existing functionality
3. cmd_stop() stops containers idempotently
4. cmd_restart() starts stopped containers and reattaches to Zellij
5. Helper functions (resolve_session_name, find_container) work correctly
6. Help text documents all subcommands
</success_criteria>

<output>
After completion, create `.planning/phases/04-session-management/04-01-SUMMARY.md`
</output>
