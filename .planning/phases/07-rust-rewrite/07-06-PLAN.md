---
phase: 07-rust-rewrite
plan: 06
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - src/commands/build.rs
  - src/commands/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "klotho build builds agent image with spinner progress"
    - "klotho build --all builds all agents"
    - "klotho rebuild builds with --no-cache"
    - "Interactive agent selection for build when no args"
  artifacts:
    - path: "src/commands/build.rs"
      provides: "Build and rebuild command implementation"
      contains: "pub fn run"
  key_links:
    - from: "src/commands/build.rs"
      to: "src/resources.rs"
      via: "extract build context"
      pattern: "resources::extract_build_context"
    - from: "src/commands/build.rs"
      to: "indicatif"
      via: "progress spinner"
      pattern: "ProgressBar"
---

<objective>
Implement build and rebuild commands - new functionality not in the bash version.

Purpose: Provide integrated build experience with progress feedback (spinner with stage names).
Output: Working build/rebuild commands with interactive selection and multi-agent support.
</objective>

<execution_context>
@/home/owen/.claude/get-shit-done/workflows/execute-plan.md
@/home/owen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-rust-rewrite/07-CONTEXT.md
@.planning/phases/07-rust-rewrite/07-02-SUMMARY.md
@.planning/phases/07-rust-rewrite/07-03-SUMMARY.md

# Reference for build process
@scripts/build.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement build command with progress spinner</name>
  <files>src/commands/build.rs</files>
  <action>
Implement build command with spinner progress:

src/commands/build.rs:
```rust
use anyhow::{bail, Context, Result};
use dialoguer::MultiSelect;
use indicatif::{ProgressBar, ProgressStyle};
use owo_colors::OwoColorize;
use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio};
use std::time::Duration;

use crate::config::{get_repo_config_dir, load_agent_config};
use crate::container::{detect_runtime, Runtime};
use crate::resources::{extract_build_context, list_embedded_agents, should_use_embedded};

/// Run build command (public API called from main.rs)
pub fn run(all: bool, agents: Vec<String>, no_cache: bool) -> Result<()> {
    let runtime = detect_runtime()?;

    // Determine which agents to build
    let agents_to_build = if all {
        get_all_agents()?
    } else if agents.is_empty() {
        // Interactive selection
        select_agents_interactive()?
    } else {
        agents
    };

    if agents_to_build.is_empty() {
        println!("No agents selected.");
        return Ok(());
    }

    // Build each agent
    for agent in &agents_to_build {
        run_build(runtime, agent, no_cache)?;
    }

    Ok(())
}

/// Internal build function (also called from start command)
pub fn run_build(runtime: Runtime, agent: &str, no_cache: bool) -> Result<()> {
    // Validate agent config exists
    let config = load_agent_config(agent)?;

    // Get build context directory
    let build_dir = if should_use_embedded() {
        extract_build_context()?
    } else {
        std::env::current_dir()?
    };

    // Validate Containerfile exists
    let containerfile = build_dir.join("Containerfile");
    if !containerfile.exists() {
        bail!("Containerfile not found in build context: {:?}", build_dir);
    }

    // Validate agent stage exists in Containerfile
    let containerfile_content = std::fs::read_to_string(&containerfile)?;
    let stage_pattern = format!("FROM .* AS {}", agent);
    if !regex_lite::Regex::new(&stage_pattern)?.is_match(&containerfile_content) {
        bail!(
            "Stage '{}' not found in Containerfile.\nAvailable stages: {}",
            agent,
            find_stages(&containerfile_content).join(", ")
        );
    }

    let image_name = format!("klotho-{}:latest", agent);

    println!();
    println!("Building agent: {}", agent.bold());
    println!("Image tag: {}", image_name);
    println!();

    // Create spinner
    let spinner = ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .template("{spinner:.green} {msg}")
            .unwrap(),
    );
    spinner.enable_steady_tick(Duration::from_millis(100));
    spinner.set_message("Starting build...");

    // Build command
    let mut cmd = Command::new(runtime.as_str());
    cmd.args(["build"]);

    if no_cache {
        cmd.arg("--no-cache");
    }

    cmd.args(["--target", agent]);
    cmd.args(["--build-arg", &format!("AGENT_NAME={}", config.name)]);
    cmd.args(["--build-arg", &format!("AGENT_INSTALL_CMD={}", config.install_cmd)]);
    cmd.args(["--build-arg", &format!("AGENT_SHELL={}", config.shell)]);
    cmd.args(["--build-arg", &format!("AGENT_LAUNCH_CMD={}", config.launch_cmd)]);
    cmd.args(["-t", &image_name]);
    cmd.arg(&build_dir);

    // Capture stderr for progress (build output goes to stderr)
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    let mut child = cmd.spawn().context("Failed to start build")?;

    // Read stderr for progress updates
    let stderr = child.stderr.take().expect("Failed to capture stderr");
    let reader = BufReader::new(stderr);

    let mut last_step = String::new();
    let mut output_buffer = Vec::new();

    for line in reader.lines() {
        let line = line?;
        output_buffer.push(line.clone());

        // Parse build progress from line
        // Podman/Docker output patterns:
        // STEP N/M: ...
        // --> Using cache ...
        // [N/M] RUN ...
        if line.contains("STEP ") || line.starts_with("[") {
            let step = extract_step_info(&line);
            if !step.is_empty() && step != last_step {
                last_step = step.clone();
                spinner.set_message(format!("{}", step));
            }
        }
    }

    let status = child.wait()?;

    spinner.finish_and_clear();

    if status.success() {
        println!("{} Build complete: {}", "✓".green(), image_name);
    } else {
        println!("{} Build failed", "✗".red());
        println!();
        println!("Build output:");
        for line in output_buffer.iter().rev().take(50).rev() {
            println!("  {}", line);
        }
        bail!("Build failed for agent: {}", agent);
    }

    Ok(())
}

fn get_all_agents() -> Result<Vec<String>> {
    if should_use_embedded() {
        Ok(list_embedded_agents())
    } else {
        let config_dir = get_repo_config_dir()?;
        crate::agent::discover_agents(&config_dir)
    }
}

fn select_agents_interactive() -> Result<Vec<String>> {
    let agents = get_all_agents()?;

    if agents.is_empty() {
        bail!("No agents found");
    }

    if agents.len() == 1 {
        return Ok(agents);
    }

    let selections = MultiSelect::new()
        .with_prompt("Select agents to build (space to select, enter to confirm)")
        .items(&agents)
        .interact()
        .context("Failed to show selection menu")?;

    if selections.is_empty() {
        return Ok(vec![]);
    }

    Ok(selections.into_iter().map(|i| agents[i].clone()).collect())
}

fn find_stages(containerfile: &str) -> Vec<String> {
    let mut stages = Vec::new();
    let re = regex_lite::Regex::new(r"FROM .* AS (\w+)").unwrap();

    for cap in re.captures_iter(containerfile) {
        if let Some(stage) = cap.get(1) {
            stages.push(stage.as_str().to_string());
        }
    }

    stages
}

fn extract_step_info(line: &str) -> String {
    // STEP 3/10: RUN apt-get update
    if let Some(idx) = line.find("STEP ") {
        let rest = &line[idx..];
        if let Some(colon) = rest.find(':') {
            let step_part = &rest[..colon];
            let action_part = rest[colon + 1..].trim();
            // Truncate action part if too long
            let action = if action_part.len() > 40 {
                format!("{}...", &action_part[..40])
            } else {
                action_part.to_string()
            };
            return format!("{}: {}", step_part, action);
        }
    }

    // [3/10] RUN apt-get update
    if line.starts_with('[') {
        if let Some(bracket_end) = line.find(']') {
            let step = &line[..bracket_end + 1];
            let action = line[bracket_end + 1..].trim();
            let action = if action.len() > 40 {
                format!("{}...", &action[..40])
            } else {
                action.to_string()
            };
            return format!("{} {}", step, action);
        }
    }

    String::new()
}
```

Add regex-lite dependency to Cargo.toml:
```toml
regex-lite = "0.1"
```

Update src/commands/mod.rs to ensure build is exported.
  </action>
  <verify>
```bash
cargo build
cargo run -- build --help
cargo run -- rebuild --help
```
  </verify>
  <done>Build command implemented with spinner progress</done>
</task>

<task type="auto">
  <name>Task 2: Wire up build and rebuild in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update main.rs to wire up build and rebuild commands:

```rust
use anyhow::Result;
use clap::Parser;
use klotho::cli::{Cli, Commands};

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Start { agent, name, paths } => {
            let agent = if agent == "claude" {
                let args: Vec<String> = std::env::args().collect();
                let explicit_agent = args.iter().any(|a| a == "-a" || a == "--agent");
                if explicit_agent {
                    Some(agent)
                } else {
                    None
                }
            } else {
                Some(agent)
            };
            klotho::commands::start::run(agent, name, paths)
        }
        Commands::Stop { name } => klotho::commands::stop::run(name),
        Commands::Restart { name } => klotho::commands::restart::run(name),
        Commands::Ls => klotho::commands::ls::run(),
        Commands::Rm { force, name } => klotho::commands::rm::run(name, force),
        Commands::Build { all, agents } => klotho::commands::build::run(all, agents, false),
        Commands::Rebuild { all, agents } => klotho::commands::build::run(all, agents, true),
    }
}
```

The key difference between build and rebuild is the `no_cache` parameter:
- `klotho build` -> `no_cache = false`
- `klotho rebuild` -> `no_cache = true` (equivalent to `podman build --no-cache`)
  </action>
  <verify>
```bash
# Build the CLI
cargo build

# Test build command
cargo run -- build claude

# Test rebuild command (--no-cache)
cargo run -- rebuild claude

# Test --all flag
cargo run -- build --all

# Test interactive selection (no args)
cargo run -- build
```
  </verify>
  <done>
Build and rebuild commands fully functional with spinner progress, multi-agent support, and interactive selection
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build

# Help text
cargo run -- build --help
cargo run -- rebuild --help

# Build single agent
cargo run -- build claude

# Rebuild (no cache)
cargo run -- rebuild claude

# Build all agents
cargo run -- build --all

# Interactive selection
cargo run -- build
```
</verification>

<success_criteria>
- build command builds agent images with spinner showing progress
- rebuild command passes --no-cache to container build
- --all flag builds all available agents
- Interactive multi-select when no agents specified
- Build errors show last 50 lines of output for debugging
- Embedded resources extracted correctly for standalone binary builds
</success_criteria>

<output>
After completion, create `.planning/phases/07-rust-rewrite/07-06-SUMMARY.md`
</output>
