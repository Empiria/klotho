---
phase: 07-rust-rewrite
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/config.rs
  - src/agent.rs
  - src/container.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Agent configs load from both repo and XDG paths"
    - "Legacy agent-session paths work with deprecation warning"
    - "Container runtime auto-detects podman or docker"
    - "Docker fallback shows warning message"
    - "--runtime flag overrides auto-detection"
  artifacts:
    - path: "src/config.rs"
      provides: "Config loading with XDG layering"
      contains: "XDG_CONFIG_HOME"
    - path: "src/agent.rs"
      provides: "Agent discovery and config structs"
      contains: "struct AgentConfig"
    - path: "src/container.rs"
      provides: "Container runtime abstraction"
      contains: "fn detect_runtime"
  key_links:
    - from: "src/agent.rs"
      to: "src/config.rs"
      via: "load_agent_config function"
      pattern: "load_agent_config"
    - from: "src/container.rs"
      to: "std::process::Command"
      via: "subprocess execution"
      pattern: "Command::new"
---

<objective>
Implement config loading and container runtime abstraction - the core infrastructure that all commands depend on.

Purpose: Replicate bash version's config system and podman interaction in Rust with proper error handling.
Output: Working config loading and container runtime detection that commands can use.
</objective>

<execution_context>
@/home/owen/.claude/get-shit-done/workflows/execute-plan.md
@/home/owen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-rust-rewrite/07-CONTEXT.md
@.planning/phases/07-rust-rewrite/07-RESEARCH.md
@.planning/phases/07-rust-rewrite/07-01-SUMMARY.md

# Reference implementation
@klotho
@config/agents/claude/config.conf
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement agent config loading</name>
  <files>src/config.rs, src/agent.rs, src/lib.rs</files>
  <action>
Create config loading that matches bash version's behavior:

src/agent.rs - Agent config structure:
```rust
use anyhow::{Context, Result};
use std::path::{Path, PathBuf};

#[derive(Debug, Clone)]
pub struct AgentConfig {
    pub name: String,
    pub description: String,
    pub install_cmd: String,
    pub launch_cmd: String,
    pub shell: String,
    pub env_vars: Option<String>,
}

impl AgentConfig {
    /// Parse KEY=value config file format
    pub fn from_file(path: &Path) -> Result<Self> {
        let contents = std::fs::read_to_string(path)
            .context(format!("Failed to read config: {:?}", path))?;

        // Validate: reject command substitution ($() or backticks)
        if contents.contains("$(") || contents.contains('`') {
            anyhow::bail!("Config contains command substitution ($() or backticks). Only KEY=value pairs allowed.");
        }

        let mut config = AgentConfig {
            name: String::new(),
            description: String::new(),
            install_cmd: String::new(),
            launch_cmd: String::new(),
            shell: String::new(),
            env_vars: None,
        };

        for line in contents.lines() {
            let line = line.trim();
            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            if let Some((key, value)) = line.split_once('=') {
                let key = key.trim();
                // Remove surrounding quotes from value
                let value = value.trim().trim_matches('"').to_string();

                match key {
                    "AGENT_NAME" => config.name = value,
                    "AGENT_DESCRIPTION" => config.description = value,
                    "AGENT_INSTALL_CMD" => config.install_cmd = value,
                    "AGENT_LAUNCH_CMD" => config.launch_cmd = value,
                    "AGENT_SHELL" => config.shell = value,
                    "AGENT_ENV_VARS" => config.env_vars = Some(value),
                    _ => {} // Ignore unknown keys
                }
            }
        }

        // Validate required fields
        if config.name.is_empty() {
            anyhow::bail!("Missing required field: AGENT_NAME");
        }
        if config.install_cmd.is_empty() {
            anyhow::bail!("Missing required field: AGENT_INSTALL_CMD");
        }
        if config.launch_cmd.is_empty() {
            anyhow::bail!("Missing required field: AGENT_LAUNCH_CMD");
        }
        if config.shell.is_empty() {
            anyhow::bail!("Missing required field: AGENT_SHELL");
        }

        Ok(config)
    }
}

/// Discover available agents from config directory
pub fn discover_agents(config_dir: &Path) -> Result<Vec<String>> {
    let agents_dir = config_dir.join("agents");
    if !agents_dir.exists() {
        anyhow::bail!("Agents directory not found: {:?}", agents_dir);
    }

    let mut agents = Vec::new();
    for entry in std::fs::read_dir(&agents_dir)? {
        let entry = entry?;
        if entry.file_type()?.is_dir() {
            if let Some(name) = entry.file_name().to_str() {
                agents.push(name.to_string());
            }
        }
    }

    agents.sort();
    Ok(agents)
}
```

src/config.rs - Path resolution with XDG layering:
```rust
use anyhow::{Context, Result};
use owo_colors::OwoColorize;
use std::path::PathBuf;
use crate::agent::AgentConfig;

/// Get the klotho config home directory
/// Checks: $XDG_CONFIG_HOME/klotho, then legacy $XDG_CONFIG_HOME/agent-session
pub fn get_config_home() -> (PathBuf, bool) {
    let config_home = std::env::var("XDG_CONFIG_HOME")
        .map(PathBuf::from)
        .unwrap_or_else(|_| {
            let home = std::env::var("HOME").expect("HOME not set");
            PathBuf::from(home).join(".config")
        });

    let klotho_config = config_home.join("klotho");
    if klotho_config.exists() {
        return (klotho_config, false);
    }

    let legacy_config = config_home.join("agent-session");
    if legacy_config.exists() {
        eprintln!("{}", "warning: ~/.config/agent-session is deprecated, please rename to ~/.config/klotho".yellow());
        return (legacy_config, true);
    }

    // Default to klotho for new installations
    (klotho_config, false)
}

/// Get the repository config directory (embedded in binary or local)
pub fn get_repo_config_dir() -> PathBuf {
    // For now, use local path relative to executable
    // Will be replaced with embedded resources in plan 03
    let exe_dir = std::env::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))
        .unwrap_or_else(|| PathBuf::from("."));

    // Check if running from repo (config/ exists alongside)
    let repo_config = PathBuf::from("config");
    if repo_config.exists() {
        return repo_config;
    }

    // Fallback to exe directory
    exe_dir.join("config")
}

/// Load agent config with XDG-style layering (repo defaults + user overrides)
pub fn load_agent_config(agent: &str) -> Result<AgentConfig> {
    let repo_config_dir = get_repo_config_dir();
    let repo_config = repo_config_dir.join("agents").join(agent).join("config.conf");

    if !repo_config.exists() {
        anyhow::bail!("No default config found for agent: {}\nExpected: {:?}", agent, repo_config);
    }

    // Load repo config (required)
    let mut config = AgentConfig::from_file(&repo_config)
        .context("Failed to load repo config")?;

    // Check for user override
    let (user_config_home, _is_legacy) = get_config_home();
    let user_config = user_config_home.join("agents").join(agent).join("config.conf");

    if user_config.exists() {
        let user_overrides = AgentConfig::from_file(&user_config)
            .context("Failed to load user config")?;

        // Override non-empty fields from user config
        if !user_overrides.description.is_empty() {
            config.description = user_overrides.description;
        }
        if !user_overrides.install_cmd.is_empty() {
            config.install_cmd = user_overrides.install_cmd;
        }
        if !user_overrides.launch_cmd.is_empty() {
            config.launch_cmd = user_overrides.launch_cmd;
        }
        if !user_overrides.shell.is_empty() {
            config.shell = user_overrides.shell;
        }
        if user_overrides.env_vars.is_some() {
            config.env_vars = user_overrides.env_vars;
        }
    }

    Ok(config)
}

/// Get environment variable with legacy fallback
pub fn get_env_with_legacy(new_name: &str, legacy_name: &str) -> Option<String> {
    if let Ok(value) = std::env::var(new_name) {
        return Some(value);
    }

    if let Ok(value) = std::env::var(legacy_name) {
        eprintln!("{}", format!("warning: {} is deprecated, please use {}", legacy_name, new_name).yellow());
        return Some(value);
    }

    None
}
```

Update src/lib.rs to include new modules:
```rust
pub mod cli;
pub mod config;
pub mod agent;
```
  </action>
  <verify>
Create a simple test in main.rs temporarily:
```rust
// In main.rs, add temporary test
let config = klotho::config::load_agent_config("claude")?;
println!("Loaded agent: {} - {}", config.name, config.description);
```
Run: cargo run -- start (will load config before hitting todo!())
  </verify>
  <done>
Config loading works: parses KEY=value format, validates security (no command substitution), supports XDG layering with legacy fallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement container runtime abstraction</name>
  <files>src/container.rs, src/lib.rs</files>
  <action>
Create container runtime abstraction that shells out to podman/docker:

src/container.rs:
```rust
use anyhow::{bail, Context, Result};
use owo_colors::OwoColorize;
use std::process::{Command, Output, Stdio};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Runtime {
    Podman,
    Docker,
}

impl Runtime {
    pub fn as_str(&self) -> &'static str {
        match self {
            Runtime::Podman => "podman",
            Runtime::Docker => "docker",
        }
    }
}

/// Detect available container runtime
/// If runtime_override is Some, use that runtime directly (validates it exists)
/// If runtime_override is None, auto-detect with priority: podman > docker
/// If neither found, returns error with install instructions
pub fn detect_runtime(runtime_override: Option<&str>) -> Result<Runtime> {
    // Handle explicit runtime override from --runtime flag
    if let Some(override_str) = runtime_override {
        match override_str.to_lowercase().as_str() {
            "podman" => {
                if Command::new("podman")
                    .arg("--version")
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                    .status()
                    .is_ok()
                {
                    return Ok(Runtime::Podman);
                }
                bail!("--runtime=podman specified but podman is not installed");
            }
            "docker" => {
                if Command::new("docker")
                    .arg("--version")
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                    .status()
                    .is_ok()
                {
                    return Ok(Runtime::Docker);
                }
                bail!("--runtime=docker specified but docker is not installed");
            }
            other => {
                bail!("Unknown runtime '{}'. Supported: podman, docker", other);
            }
        }
    }

    // Auto-detection: check podman first
    if Command::new("podman")
        .arg("--version")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .is_ok()
    {
        return Ok(Runtime::Podman);
    }

    // Fallback to docker
    if Command::new("docker")
        .arg("--version")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .is_ok()
    {
        eprintln!("{}", "warning: podman not found, using docker".yellow());
        return Ok(Runtime::Docker);
    }

    // Neither found
    let install_hint = if cfg!(target_os = "macos") {
        "Install podman: brew install podman && podman machine init && podman machine start"
    } else if cfg!(target_os = "linux") {
        "Install podman: sudo apt install podman (Debian/Ubuntu) or sudo dnf install podman (Fedora)"
    } else {
        "Install podman from https://podman.io/"
    };

    bail!("Neither podman nor docker found.\n{}", install_hint);
}

/// Container status
#[derive(Debug, Clone, PartialEq)]
pub enum ContainerStatus {
    Running,
    Stopped,
    NotFound,
}

/// Check if a container exists and its status
pub fn container_status(runtime: Runtime, name: &str) -> Result<ContainerStatus> {
    let output = Command::new(runtime.as_str())
        .args(["ps", "-a", "--format", "{{.Names}}|{{.Status}}"])
        .output()
        .context("Failed to run container ps")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("{} ps failed: {}", runtime.as_str(), stderr);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    for line in stdout.lines() {
        if let Some((container_name, status)) = line.split_once('|') {
            if container_name == name {
                if status.starts_with("Up") {
                    return Ok(ContainerStatus::Running);
                } else {
                    return Ok(ContainerStatus::Stopped);
                }
            }
        }
    }

    Ok(ContainerStatus::NotFound)
}

/// Check if an image exists (supports both new and legacy naming)
pub fn image_exists(runtime: Runtime, agent: &str) -> Result<bool> {
    // Check new naming first
    let new_name = format!("klotho-{}:latest", agent);
    if check_image(runtime, &new_name)? {
        return Ok(true);
    }

    // Check legacy naming
    let legacy_name = format!("agent-session-{}:latest", agent);
    if check_image(runtime, &legacy_name)? {
        eprintln!("{}", format!("note: using legacy image {}", legacy_name).yellow());
        return Ok(true);
    }

    Ok(false)
}

fn check_image(runtime: Runtime, name: &str) -> Result<bool> {
    let status = Command::new(runtime.as_str())
        .args(["image", "exists", name])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .context("Failed to check image")?;

    Ok(status.success())
}

/// Get the image name to use (prefers new naming, falls back to legacy)
pub fn get_image_name(runtime: Runtime, agent: &str) -> Result<String> {
    let new_name = format!("klotho-{}:latest", agent);
    if check_image(runtime, &new_name)? {
        return Ok(new_name);
    }

    let legacy_name = format!("agent-session-{}:latest", agent);
    if check_image(runtime, &legacy_name)? {
        return Ok(legacy_name);
    }

    // Default to new naming for new builds
    Ok(new_name)
}

/// List containers matching klotho/agent-session pattern
pub fn list_containers(runtime: Runtime) -> Result<Vec<ContainerInfo>> {
    let output = Command::new(runtime.as_str())
        .args(["ps", "-a", "--format", "{{.Names}}|{{.Status}}"])
        .output()
        .context("Failed to list containers")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("{} ps failed: {}", runtime.as_str(), stderr);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut containers = Vec::new();

    for line in stdout.lines() {
        if let Some((name, status)) = line.split_once('|') {
            // Match klotho-<agent>-<session> or <agent>-<session> patterns
            if let Some(info) = parse_container_name(name, status) {
                containers.push(info);
            }
        }
    }

    Ok(containers)
}

#[derive(Debug, Clone)]
pub struct ContainerInfo {
    pub full_name: String,
    pub session_name: String,
    pub agent: String,
    pub is_running: bool,
    pub is_legacy: bool,
}

fn parse_container_name(name: &str, status: &str) -> Option<ContainerInfo> {
    let is_running = status.starts_with("Up");

    // Try new format: klotho-<agent>-<session>
    if let Some(rest) = name.strip_prefix("klotho-") {
        if let Some(idx) = rest.find('-') {
            let agent = &rest[..idx];
            let session = &rest[idx + 1..];
            return Some(ContainerInfo {
                full_name: name.to_string(),
                session_name: session.to_string(),
                agent: agent.to_string(),
                is_running,
                is_legacy: false,
            });
        }
    }

    // Try legacy format: <agent>-<session>
    // Only match known agents to avoid false positives
    let known_agents = ["claude", "opencode"];
    for agent in known_agents {
        if let Some(session) = name.strip_prefix(&format!("{}-", agent)) {
            return Some(ContainerInfo {
                full_name: name.to_string(),
                session_name: session.to_string(),
                agent: agent.to_string(),
                is_running,
                is_legacy: true,
            });
        }
    }

    None
}

/// Find container by session name (searches both new and legacy naming)
pub fn find_container(runtime: Runtime, session_name: &str) -> Result<Option<ContainerInfo>> {
    let containers = list_containers(runtime)?;

    for container in containers {
        if container.session_name == session_name {
            return Ok(Some(container));
        }
    }

    Ok(None)
}

/// Stop a container
pub fn stop_container(runtime: Runtime, name: &str) -> Result<()> {
    let status = Command::new(runtime.as_str())
        .args(["stop", name])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .context("Failed to stop container")?;

    // Stop is idempotent - already stopped is OK
    if !status.success() {
        // Check if it was already stopped
        if container_status(runtime, name)? == ContainerStatus::Stopped {
            return Ok(());
        }
    }

    Ok(())
}

/// Start a container
pub fn start_container(runtime: Runtime, name: &str) -> Result<()> {
    let output = Command::new(runtime.as_str())
        .args(["start", name])
        .output()
        .context("Failed to start container")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("Failed to start container: {}", stderr);
    }

    Ok(())
}

/// Remove a container
pub fn remove_container(runtime: Runtime, name: &str) -> Result<()> {
    let output = Command::new(runtime.as_str())
        .args(["rm", name])
        .output()
        .context("Failed to remove container")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("Failed to remove container: {}", stderr);
    }

    Ok(())
}
```

Update src/lib.rs:
```rust
pub mod cli;
pub mod config;
pub mod agent;
pub mod container;
```
  </action>
  <verify>
Add test to main.rs:
```rust
// Test runtime detection with override
let runtime = klotho::container::detect_runtime(None)?;  // Auto-detect
println!("Auto-detected runtime: {:?}", runtime);

let runtime = klotho::container::detect_runtime(Some("podman"))?;  // Explicit
println!("Explicit runtime: {:?}", runtime);

let containers = klotho::container::list_containers(runtime)?;
println!("Found {} klotho containers", containers.len());
```
Run: cargo run -- ls (will test detection and listing before hitting todo!())

Also test --runtime flag:
```bash
cargo run -- --runtime podman ls
cargo run -- --runtime docker ls
cargo run -- --runtime invalid ls  # Should error
```
  </verify>
  <done>
Container abstraction works: runtime detection with --runtime override support, auto-detection fallback with podman priority, container listing, status checks, start/stop/remove operations
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build

# Test config loading (modify main.rs temporarily to test)
cargo run -- start  # Should load claude config before todo!()

# Test runtime auto-detection
cargo run -- ls     # Should detect podman/docker before todo!()

# Test runtime override
cargo run -- --runtime podman ls
cargo run -- --runtime docker ls
```
</verification>

<success_criteria>
- Config loading parses KEY=value format correctly
- Security validation rejects command substitution
- XDG path layering works with legacy fallback + warning
- Runtime detection finds podman (or docker with warning)
- --runtime flag overrides auto-detection
- Invalid --runtime value gives clear error
- Container listing parses both new and legacy naming patterns
</success_criteria>

<output>
After completion, create `.planning/phases/07-rust-rewrite/07-02-SUMMARY.md`
</output>
