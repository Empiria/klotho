---
phase: 07-rust-rewrite
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - src/commands/mod.rs
  - src/commands/start.rs
  - src/main.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "klotho start creates new container with mounts"
    - "klotho start -n existing attaches to existing session"
    - "klotho start -a claude selects specific agent"
    - "Interactive agent selection works when no -a flag"
    - "Legacy container naming is detected and used"
  artifacts:
    - path: "src/commands/start.rs"
      provides: "Start command implementation"
      contains: "pub fn run"
    - path: "src/commands/mod.rs"
      provides: "Command module re-exports"
      contains: "pub mod start"
  key_links:
    - from: "src/commands/start.rs"
      to: "src/container.rs"
      via: "container operations"
      pattern: "container::"
    - from: "src/commands/start.rs"
      to: "src/config.rs"
      via: "config loading"
      pattern: "config::"
---

<objective>
Implement the start command - the most complex command that creates sessions, handles mounts, and attaches to Zellij.

Purpose: Core functionality for creating and attaching to agent sessions.
Output: Working start command with interactive selection, mounts, and Zellij attachment.
</objective>

<execution_context>
@/home/owen/.claude/get-shit-done/workflows/execute-plan.md
@/home/owen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-rust-rewrite/07-CONTEXT.md
@.planning/phases/07-rust-rewrite/07-02-SUMMARY.md
@.planning/phases/07-rust-rewrite/07-03-SUMMARY.md

# Reference implementation
@klotho
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create commands module structure</name>
  <files>src/commands/mod.rs, src/lib.rs</files>
  <action>
Create commands module structure:

src/commands/mod.rs:
```rust
pub mod start;
// Other commands will be added in subsequent plans
```

Update src/lib.rs:
```rust
pub mod cli;
pub mod config;
pub mod agent;
pub mod container;
pub mod resources;
pub mod commands;
```

This establishes the module structure for all commands.
  </action>
  <verify>cargo build compiles without errors</verify>
  <done>Commands module structure exists</done>
</task>

<task type="auto">
  <name>Task 2: Implement start command</name>
  <files>src/commands/start.rs, src/main.rs</files>
  <action>
Implement start command matching bash version's behavior:

src/commands/start.rs:
```rust
use anyhow::{bail, Context, Result};
use dialoguer::Select;
use owo_colors::OwoColorize;
use std::path::PathBuf;
use std::process::{Command, Stdio};

use crate::agent::discover_agents;
use crate::config::{get_config_home, get_env_with_legacy, get_repo_config_dir, load_agent_config};
use crate::container::{
    container_status, detect_runtime, find_container, get_image_name, image_exists,
    start_container, ContainerStatus, Runtime,
};

pub fn run(agent: Option<String>, name: String, paths: Vec<String>) -> Result<()> {
    let runtime = detect_runtime()?;

    // Determine agent (interactive selection if not specified)
    let agent_type = match agent {
        Some(a) => a,
        None => select_agent_interactive()?,
    };

    // Load agent config
    let config = load_agent_config(&agent_type)?;

    // Ensure image is built
    ensure_image_built(runtime, &agent_type)?;

    // Container naming
    let container_name = format!("klotho-{}-{}", agent_type, name);
    let legacy_container = format!("{}-{}", agent_type, name);

    // Check if container exists (new naming)
    match container_status(runtime, &container_name)? {
        ContainerStatus::Running => {
            println!("Attaching to '{}'...", name);
            return attach_zellij(runtime, &container_name, &name, &config);
        }
        ContainerStatus::Stopped => {
            println!("Starting '{}'...", name);
            start_container(runtime, &container_name)?;
            std::thread::sleep(std::time::Duration::from_secs(1));
            return attach_zellij(runtime, &container_name, &name, &config);
        }
        ContainerStatus::NotFound => {}
    }

    // Check for legacy container
    match container_status(runtime, &legacy_container)? {
        ContainerStatus::Running => {
            eprintln!(
                "{}",
                format!("note: attaching to legacy container {}", legacy_container).yellow()
            );
            return attach_zellij(runtime, &legacy_container, &name, &config);
        }
        ContainerStatus::Stopped => {
            eprintln!(
                "{}",
                format!("note: starting legacy container {}", legacy_container).yellow()
            );
            start_container(runtime, &legacy_container)?;
            std::thread::sleep(std::time::Duration::from_secs(1));
            return attach_zellij(runtime, &legacy_container, &name, &config);
        }
        ContainerStatus::NotFound => {}
    }

    // Need to create new container - resolve paths
    let paths = if paths.is_empty() {
        vec![std::env::current_dir()
            .context("Failed to get current directory")?
            .to_string_lossy()
            .to_string()]
    } else {
        paths
    };

    // Validate paths exist
    for path in &paths {
        if !PathBuf::from(path).exists() {
            bail!("Path does not exist: {}", path);
        }
    }

    // Build mount arguments
    let mut mounts = Vec::new();
    let mut first_dir = String::new();

    for path in &paths {
        let abs_path = std::fs::canonicalize(path)
            .context(format!("Failed to resolve path: {}", path))?;
        let dir_name = abs_path
            .file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| "project".to_string());
        let container_path = format!("/workspace/{}", dir_name);

        mounts.push(format!(
            "-v={}:{}:Z",
            abs_path.display(),
            container_path
        ));

        if first_dir.is_empty() {
            first_dir = container_path;
        }
    }

    // KOB mount (for symlink resolution)
    if let Some(kob_path) = get_env_with_legacy("KLOTHO_KOB", "AGENT_SESSION_KOB") {
        if PathBuf::from(&kob_path).is_dir() {
            mounts.push(format!("-v={}:{}:Z", kob_path, kob_path));
        } else {
            eprintln!("{}", format!("warning: KLOTHO_KOB path does not exist: {}", kob_path).yellow());
        }
    }

    // Extra mounts
    if let Some(extra) = get_env_with_legacy("KLOTHO_MOUNTS", "AGENT_SESSION_MOUNTS") {
        for mount_path in extra.split(':') {
            if PathBuf::from(mount_path).exists() {
                mounts.push(format!("-v={}:{}:ro", mount_path, mount_path));
            } else {
                eprintln!("{}", format!("warning: KLOTHO_MOUNTS path does not exist: {}", mount_path).yellow());
            }
        }
    }

    // Optional mounts (only if directory exists)
    let home = std::env::var("HOME").context("HOME not set")?;
    let optional_mounts = [
        (format!("{}/.claude", home), "/config/.claude:Z"),
        (format!("{}/.local/share/claude", home), "/home/agent/.local/share/claude:Z"),
        (format!("{}/.config/opencode", home), "/config/opencode:Z"),
        (format!("{}/.local/share/opencode", home), "/home/agent/.local/share/opencode:Z"),
        (format!("{}/.config/zellij", home), "/config/zellij:ro"),
    ];

    for (host_path, container_path) in &optional_mounts {
        if PathBuf::from(host_path).is_dir() {
            mounts.push(format!("-v={}:{}", host_path, container_path));
        }
    }

    // Claude json file (required)
    let claude_json = format!("{}/.claude.json", home);
    if PathBuf::from(&claude_json).exists() {
        mounts.push(format!("-v={}:/home/agent/.claude.json:Z", claude_json));
    }

    // Get image name
    let image_name = get_image_name(runtime, &agent_type)?;

    println!("Starting new session '{}'...", name);

    // Build podman run command
    let mut cmd = Command::new(runtime.as_str());
    cmd.args(["run", "-d", "--name", &container_name, "--userns=keep-id"]);
    cmd.args(["--workdir", &first_dir]);

    for mount in &mounts {
        cmd.arg(mount);
    }

    cmd.arg(&image_name);
    cmd.args(["bash", "-c", "trap \"exit 0\" TERM; while :; do sleep 1; done"]);

    let output = cmd.output().context("Failed to run container")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("Failed to create container: {}", stderr);
    }

    // Wait for container to be ready
    std::thread::sleep(std::time::Duration::from_secs(1));

    // Attach to zellij
    attach_zellij(runtime, &container_name, &name, &config)
}

fn select_agent_interactive() -> Result<String> {
    let config_dir = get_repo_config_dir()?;
    let agents = discover_agents(&config_dir)?;

    if agents.is_empty() {
        bail!("No agents found in config/agents/");
    }

    // Skip menu if only one agent
    if agents.len() == 1 {
        return Ok(agents[0].clone());
    }

    // Build display items with build status
    let runtime = detect_runtime()?;
    let items: Vec<String> = agents
        .iter()
        .map(|agent| {
            let status = if image_exists(runtime, agent).unwrap_or(false) {
                "ready"
            } else {
                "not built"
            };
            format!("{} ({})", agent, status)
        })
        .collect();

    let selection = Select::new()
        .with_prompt("Select agent")
        .items(&items)
        .default(0)
        .interact()
        .context("Failed to show selection menu")?;

    Ok(agents[selection].clone())
}

fn ensure_image_built(runtime: Runtime, agent: &str) -> Result<()> {
    if image_exists(runtime, agent)? {
        return Ok(());
    }

    // Prompt to build
    println!();
    print!("Image not built. Build now? [y/N] ");
    std::io::Write::flush(&mut std::io::stdout())?;

    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let answer = input.trim().to_lowercase();

    if answer == "y" || answer == "yes" {
        // Build using embedded resources
        println!("Building {}...", agent);
        crate::commands::build::run_build(runtime, agent, false)?;
    } else {
        bail!("Cannot start session without built image.");
    }

    Ok(())
}

fn attach_zellij(
    runtime: Runtime,
    container_name: &str,
    session_name: &str,
    config: &crate::agent::AgentConfig,
) -> Result<()> {
    // Check if zellij session exists
    let check = Command::new(runtime.as_str())
        .args(["exec", container_name, "zellij", "list-sessions"])
        .output()
        .context("Failed to list zellij sessions")?;

    let stdout = String::from_utf8_lossy(&check.stdout);
    // Strip ANSI codes for comparison
    let clean_output: String = stdout
        .chars()
        .filter(|c| !c.is_control() || *c == '\n')
        .collect();
    let session_exists = clean_output
        .lines()
        .any(|line| line.trim().starts_with(session_name));

    // Build the attach/create command
    let zellij_cmd = if session_exists {
        // Attach to existing session
        format!(
            "zellij attach '{}'; zellij list-sessions 2>/dev/null | sed 's/\\x1b\\[[0-9;]*m//g' | grep -q '^{} ' || exec {}",
            session_name, session_name, config.shell
        )
    } else {
        // Create new session with agent wrapper
        format!(
            "zellij -s '{}'; zellij list-sessions 2>/dev/null | sed 's/\\x1b\\[[0-9;]*m//g' | grep -q '^{} ' || exec {}",
            session_name, session_name, config.shell
        )
    };

    // Run interactive exec
    let shell_env = format!("/home/agent/.local/bin/{}-session", config.name);
    let mut cmd = Command::new(runtime.as_str());
    cmd.args(["exec", "-it"]);
    cmd.args(["-e", &format!("SHELL={}", shell_env)]);
    cmd.args(["-e", &format!("AGENT_LAUNCH_CMD={}", config.launch_cmd)]);
    cmd.args([container_name, "bash", "-c", &zellij_cmd]);

    // This is interactive - we need to inherit stdio
    cmd.stdin(Stdio::inherit());
    cmd.stdout(Stdio::inherit());
    cmd.stderr(Stdio::inherit());

    let status = cmd.status().context("Failed to exec into container")?;

    if !status.success() {
        bail!("Container exec exited with error");
    }

    Ok(())
}
```

Update src/main.rs to use the command:
```rust
use anyhow::Result;
use clap::Parser;
use klotho::cli::{Cli, Commands};

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Start { agent, name, paths } => {
            // Convert empty string agent to None for interactive selection
            let agent = if agent == "claude" && std::env::args().all(|a| a != "-a" && a != "--agent") {
                None
            } else {
                Some(agent)
            };
            klotho::commands::start::run(agent, name, paths)
        }
        Commands::Stop { name } => {
            todo!("Implement stop command")
        }
        Commands::Restart { name } => {
            todo!("Implement restart command")
        }
        Commands::Ls => {
            todo!("Implement ls command")
        }
        Commands::Rm { force, name } => {
            todo!("Implement rm command")
        }
        Commands::Build { all, agents } => {
            todo!("Implement build command")
        }
        Commands::Rebuild { all, agents } => {
            todo!("Implement rebuild command")
        }
    }
}
```

Note: The start command references build::run_build which will be implemented in plan 05. For now, add a stub in src/commands/build.rs:
```rust
use anyhow::Result;
use crate::container::Runtime;

pub fn run_build(_runtime: Runtime, _agent: &str, _no_cache: bool) -> Result<()> {
    todo!("Build command will be implemented in plan 05")
}
```

And update src/commands/mod.rs:
```rust
pub mod start;
pub mod build;
```
  </action>
  <verify>
```bash
# Build succeeds
cargo build

# Test help
cargo run -- start --help

# Test with existing session (if you have one from bash version)
cargo run -- start -n default

# Test interactive selection (without -a flag)
cargo run -- start -n test ~/projects/some-project
```
  </verify>
  <done>
Start command works: creates containers, mounts paths, handles legacy naming, interactive agent selection, attaches to Zellij
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build

# Help text correct
cargo run -- start --help

# Interactive flow (no -a flag triggers selection)
cargo run -- start

# Explicit agent
cargo run -- start -a claude -n test

# Attach to existing (if container exists)
cargo run -- start -n default

# Create new with path
cargo run -- start -n test-session ~/projects/test
```
</verification>

<success_criteria>
- start command creates containers with correct mounts
- Interactive agent selection shown when -a not provided
- Existing sessions detected and attached (both new and legacy naming)
- Zellij attachment works with TTY
- Environment variables (KLOTHO_MOUNTS, KLOTHO_KOB) supported with legacy fallback
</success_criteria>

<output>
After completion, create `.planning/phases/07-rust-rewrite/07-04-SUMMARY.md`
</output>
