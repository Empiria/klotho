#!/bin/bash
set -euo pipefail

# Resolve script directory (follow symlinks)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

show_help() {
    cat << 'EOF'
Usage: agent-session [-a AGENT] [-n NAME] [project-paths...]

Run AI agents in isolated containers with persistent Zellij sessions.

Options:
  -a, --agent AGENT  Agent to use (default: "claude")
  -n, --name NAME    Session name (default: "default")
  -h, --help         Show this help message

Examples:
  agent-session                                  # new session with current dir
  agent-session ~/projects/repo-a               # new session with specific project
  agent-session -n frontend ~/projects/webapp   # named session "frontend"
  agent-session -n backend ~/api ~/libs         # multiple repos in one session
  agent-session -n frontend                     # reattach to existing session
  agent-session -a claude -n test ~/project     # explicit agent selection

Session lifecycle:
  Sessions run in the background and persist across terminal disconnects.
  Close terminal or Ctrl+C to detach - session keeps running.
  Run agent-session with same name to reattach.

  podman ps --filter "name=agent-"                 # list running sessions
  podman stop agent-NAME && podman rm agent-NAME   # permanently stop a session

Environment variables:
  AGENT_SESSION_MOUNTS    Extra host paths to mount (colon-separated)
                          Paths are mounted at the same location in container.
                          Example: AGENT_SESSION_MOUNTS="$HOME/dotfiles:$HOME/scripts"

  AGENT_SESSION_KOB       Path to kob repo for projects with symlinks to external
                          planning/config repos. Mounted at same path in container
                          so existing symlinks resolve correctly.
                          Example: AGENT_SESSION_KOB="/home/user/projects/my-kob-repo"
                          Tip: Use direnv to set this per-project in .envrc
EOF
}

# Discover available agents from config directories
discover_agents() {
    mapfile -t agents < <(
        find $SCRIPT_DIR/config/agents -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null \
        | LC_COLLATE=C sort
    )

    if [ ${#agents[@]} -eq 0 ]; then
        echo "error: no agents found in config/agents/" >&2
        exit 1
    fi
}

# Check if agent image is built
agent_is_built() {
    local agent="$1"
    podman image exists "agent-session-${agent}:latest" 2>/dev/null
}

# Get agent display name with build status
agent_display() {
    local agent="$1"
    local name="${agent^}"  # Capitalize first letter
    if agent_is_built "$agent"; then
        echo "$name (ready)"
    else
        echo "$name (not built)"
    fi
}

# Show interactive agent selection menu
# Sets global AGENT_TYPE variable based on user selection
select_agent_interactive() {
    discover_agents

    # Skip menu if only one agent
    if [ ${#agents[@]} -eq 1 ]; then
        AGENT_TYPE="${agents[0]}"
        return
    fi

    echo "Available agents:"
    local i=1
    for agent in "${agents[@]}"; do
        echo "  $i. $(agent_display "$agent")"
        ((i++))
    done
    echo ""

    PS3="Select agent (default: ${agents[0]}): "
    select choice in "${agents[@]}"; do
        if [[ -z "$REPLY" ]]; then
            # Empty input = default (first in list)
            AGENT_TYPE="${agents[0]}"
            break
        elif [[ -n "$choice" ]]; then
            AGENT_TYPE="$choice"
            break
        else
            echo "Invalid selection. Enter a number 1-${#agents[@]} or press Enter for default."
        fi
    done
}

AGENT_TYPE="claude"
AGENT_SPECIFIED="false"
SESSION_NAME="default"
PATHS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -a|--agent)
            if [[ -z "${2:-}" || "$2" == -* ]]; then
                echo "error: -a/--agent requires an agent name" >&2
                echo >&2
                show_help >&2
                exit 1
            fi
            AGENT_TYPE="$2"
            AGENT_SPECIFIED="true"
            shift 2
            ;;
        -n|--name)
            if [[ -z "${2:-}" || "$2" == -* ]]; then
                echo "error: -n/--name requires a session name" >&2
                echo >&2
                show_help >&2
                exit 1
            fi
            SESSION_NAME="$2"
            shift 2
            ;;
        -*)
            echo "error: unknown option: $1" >&2
            echo >&2
            show_help >&2
            exit 1
            ;;
        *)
            PATHS+=("$1")
            shift
            ;;
    esac
done

# Validate config file format - reject command substitution
validate_config() {
    local config_file="$1"

    # Check file exists and is readable
    if [[ ! -f "$config_file" ]] || [[ ! -r "$config_file" ]]; then
        echo "error: config file not found or not readable: $config_file" >&2
        return 1
    fi

    # Reject command substitution which would execute during sourcing
    if grep -qE '`|\$\(' "$config_file"; then
        echo "error: config contains command substitution (\$() or backticks)" >&2
        echo "config files may only contain KEY=value pairs and variable expansion (\$VAR)" >&2
        return 1
    fi

    return 0
}

# Prompt to build agent if image doesn't exist
ensure_agent_built() {
    local agent="$1"
    local image="agent-session-${agent}:latest"

    if ! podman image exists "$image" 2>/dev/null; then
        echo ""
        read -p "Image not built. Build now? [y/N] " answer
        answer="${answer:-N}"
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            echo "Building ${agent}..."
            $SCRIPT_DIR/scripts/build.sh "$agent" || {
                echo "error: build failed" >&2
                exit 1
            }
        else
            echo "Cannot start session without built image."
            exit 1
        fi
    fi
}

# Load agent config with XDG-style layering
load_agent_config() {
    local agent="$1"
    local config_home="${XDG_CONFIG_HOME:-$HOME/.config}"
    local user_config="$config_home/agent-session/agents/$agent/config.conf"
    local repo_config="$SCRIPT_DIR/config/agents/$agent/config.conf"

    # Load repo default first (must exist)
    if [[ ! -f "$repo_config" ]]; then
        echo "error: no default config found for agent: $agent" >&2
        echo "expected: $repo_config" >&2
        return 1
    fi

    validate_config "$repo_config" || return 1
    source "$repo_config"

    # Override with user config if present
    if [[ -f "$user_config" ]]; then
        validate_config "$user_config" || return 1
        source "$user_config"
    fi

    return 0
}

# If no agent specified via flag, show interactive menu
# This sets AGENT_TYPE before load_agent_config is called
if [[ "$AGENT_SPECIFIED" != "true" ]]; then
    select_agent_interactive
fi

# Load agent config (uses AGENT_TYPE set by flag or menu)
load_agent_config "$AGENT_TYPE" || exit 1

# Ensure image is built
ensure_agent_built "$AGENT_TYPE"

CONTAINER_NAME="${AGENT_TYPE}-${SESSION_NAME}"
IMAGE_NAME="agent-session-${AGENT_TYPE}:latest"

# Helper to attach or create zellij session
# After zellij exits: if session still exists (detach), return to host; if gone (quit), drop to shell
attach_zellij() {
    # Strip ANSI color codes when checking for existing sessions
    if podman exec "$CONTAINER_NAME" zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q "^$SESSION_NAME "; then
        podman exec -it "$CONTAINER_NAME" bash -c "zellij attach '$SESSION_NAME'; zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q '^$SESSION_NAME ' || exec $AGENT_SHELL"
    else
        # Start new session with agent wrapper as the shell (runs agent, then drops to configured shell)
        podman exec -it -e SHELL=/home/agent/.local/bin/${AGENT_NAME}-session -e AGENT_LAUNCH_CMD="$AGENT_LAUNCH_CMD" "$CONTAINER_NAME" bash -c "zellij -s '$SESSION_NAME'; zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q '^$SESSION_NAME ' || exec $AGENT_SHELL"
    fi
}

# Check if container exists and is running
if podman ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    echo "Attaching to '$SESSION_NAME'..."
    attach_zellij
    exit 0
fi

# Check if container exists but stopped
if podman ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
    echo "Starting '$SESSION_NAME'..."
    podman start "$CONTAINER_NAME"
    sleep 1  # Wait for container to be ready
    attach_zellij
    exit 0
fi

# Need paths to create a new session
if [ ${#PATHS[@]} -eq 0 ]; then
    PATHS=("$(pwd)")
fi

# Validate paths exist
for path in "${PATHS[@]}"; do
    if [[ ! -e "$path" ]]; then
        echo "error: path does not exist: $path" >&2
        exit 1
    fi
done

# Build mount arguments from provided paths
MOUNTS=""
FIRST_DIR=""
for path in "${PATHS[@]}"; do
    abs_path=$(realpath "$path")
    dir_name=$(basename "$abs_path")
    container_path="/workspace/$dir_name"
    MOUNTS="$MOUNTS -v $abs_path:$container_path:Z"
    [[ -z "$FIRST_DIR" ]] && FIRST_DIR="$container_path"
done

# Mount kob repo at same path so symlinks resolve correctly
KOB_MOUNT=""
if [[ -n "${AGENT_SESSION_KOB:-}" ]]; then
    if [[ -d "$AGENT_SESSION_KOB" ]]; then
        KOB_MOUNT="-v $AGENT_SESSION_KOB:$AGENT_SESSION_KOB:Z"
    else
        echo "warning: AGENT_SESSION_KOB path does not exist: $AGENT_SESSION_KOB" >&2
    fi
fi

# Build extra mounts from AGENT_SESSION_MOUNTS env var
EXTRA_MOUNTS=""
if [[ -n "${AGENT_SESSION_MOUNTS:-}" ]]; then
    IFS=':' read -ra MOUNT_PATHS <<< "$AGENT_SESSION_MOUNTS"
    for mount_path in "${MOUNT_PATHS[@]}"; do
        if [[ -e "$mount_path" ]]; then
            EXTRA_MOUNTS="$EXTRA_MOUNTS -v $mount_path:$mount_path:ro"
        else
            echo "warning: AGENT_SESSION_MOUNTS path does not exist: $mount_path" >&2
        fi
    done
fi

# Build optional mounts - only include if directory exists
OPTIONAL_MOUNTS=""
[[ -d "$HOME/.claude" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.claude:/config/.claude:Z"
[[ -d "$HOME/.local/share/claude" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.local/share/claude:/home/agent/.local/share/claude:Z"
[[ -d "$HOME/.config/opencode" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.config/opencode:/config/opencode:Z"
[[ -d "$HOME/.local/share/opencode" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.local/share/opencode:/home/agent/.local/share/opencode:Z"
[[ -d "$HOME/.config/zellij" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.config/zellij:/config/zellij:ro"

# Mount bundled OpenCode MCP config if no user config exists
if [[ "$AGENT_TYPE" == "opencode" ]] && [[ ! -d "$HOME/.config/opencode" ]] && [[ -f "$SCRIPT_DIR/config/agents/opencode/opencode.json" ]]; then
    mkdir -p /tmp/opencode-config
    cp $SCRIPT_DIR/config/agents/opencode/opencode.json /tmp/opencode-config/
    OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v /tmp/opencode-config:/config/opencode:Z"
fi

echo "Starting new session '$SESSION_NAME'..."
podman run -d \
    --name "$CONTAINER_NAME" \
    --userns=keep-id \
    --workdir "$FIRST_DIR" \
    -v "$HOME/.claude.json:/home/agent/.claude.json:Z" \
    $OPTIONAL_MOUNTS \
    $EXTRA_MOUNTS \
    $MOUNTS \
    $KOB_MOUNT \
    "$IMAGE_NAME" \
    bash -c 'trap "exit 0" TERM; while :; do sleep 1; done'

# Wait for container to be ready
sleep 1
attach_zellij
