#!/bin/bash
set -euo pipefail

# Resolve script directory (follow symlinks)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
    readonly COLOR_GREEN='\033[0;32m'
    readonly COLOR_RED='\033[0;31m'
    readonly COLOR_RESET='\033[0m'
else
    readonly COLOR_GREEN=''
    readonly COLOR_RED=''
    readonly COLOR_RESET=''
fi

show_help() {
    cat << 'EOF'
Usage: agent-session <command> [options]

Run AI agents in isolated containers with persistent Zellij sessions.

Commands:
  start   Create a new session or attach to existing one
  stop    Stop a running session
  restart Start a stopped session and reattach
  ls      List all sessions with status
  rm      Remove a stopped session

Run 'agent-session <command> --help' for command-specific help.

Examples:
  agent-session start                           # new session with current dir
  agent-session start -n frontend ~/webapp      # named session "frontend"
  agent-session ls                              # list all sessions
  agent-session stop frontend                   # stop a session
  agent-session restart frontend                # restart and reattach
  agent-session rm frontend                     # remove stopped session
EOF
}

show_start_help() {
    cat << 'EOF'
Usage: agent-session start [-a AGENT] [-n NAME] [project-paths...]

Create a new agent session or attach to an existing one.

Options:
  -a, --agent AGENT  Agent to use (default: "claude")
  -n, --name NAME    Session name (default: "default")
  -h, --help         Show this help message

Examples:
  agent-session start                                  # new session with current dir
  agent-session start ~/projects/repo-a               # new session with specific project
  agent-session start -n frontend ~/projects/webapp   # named session "frontend"
  agent-session start -n backend ~/api ~/libs         # multiple repos in one session
  agent-session start -n frontend                     # reattach to existing session
  agent-session start -a claude -n test ~/project     # explicit agent selection

Session lifecycle:
  Sessions run in the background and persist across terminal disconnects.
  Close terminal or Ctrl+C to detach - session keeps running.
  Run 'agent-session start' with same name to reattach.

Environment variables:
  AGENT_SESSION_MOUNTS    Extra host paths to mount (colon-separated)
                          Paths are mounted at the same location in container.
                          Example: AGENT_SESSION_MOUNTS="$HOME/dotfiles:$HOME/scripts"

  AGENT_SESSION_KOB       Path to kob repo for projects with symlinks to external
                          planning/config repos. Mounted at same path in container
                          so existing symlinks resolve correctly.
                          Example: AGENT_SESSION_KOB="/home/user/projects/my-kob-repo"
                          Tip: Use direnv to set this per-project in .envrc
EOF
}

show_stop_help() {
    cat << 'EOF'
Usage: agent-session stop [SESSION_NAME]

Stop a running session. The session can be restarted later.

Arguments:
  SESSION_NAME    Name of session to stop (default: "default")

Options:
  -h, --help      Show this help message

Examples:
  agent-session stop              # stop session named "default"
  agent-session stop frontend     # stop session named "frontend"

Notes:
  - Stopping an already-stopped session succeeds silently
  - Use 'agent-session ls' to see session status
EOF
}

show_restart_help() {
    cat << 'EOF'
Usage: agent-session restart [SESSION_NAME]

Restart a stopped session and reattach to its Zellij terminal.

Arguments:
  SESSION_NAME    Name of session to restart (default: "default")

Options:
  -h, --help      Show this help message

Examples:
  agent-session restart              # restart session named "default"
  agent-session restart frontend     # restart session named "frontend"

Notes:
  - If session is already running, simply reattaches
  - Use 'agent-session ls' to see session status
EOF
}

show_ls_help() {
    cat << 'EOF'
Usage: agent-session ls

List all agent sessions with their status.

Options:
  -h, --help      Show this help message

Output columns:
  NAME    Session name
  AGENT   Agent type (claude, opencode, etc.)
  STATUS  running (green) or stopped (red)
EOF
}

show_rm_help() {
    cat << 'EOF'
Usage: agent-session rm [-f|--force] [SESSION_NAME]

Remove a stopped session container.

Arguments:
  SESSION_NAME    Name of session to remove (default: "default")

Options:
  -f, --force     Skip confirmation prompt
  -h, --help      Show this help message

Examples:
  agent-session rm frontend          # remove with confirmation
  agent-session rm -f frontend       # remove without confirmation

Notes:
  - Cannot remove a running session (stop it first)
  - Removal is permanent - container and its state are deleted
EOF
}

# Discover available agents from config directories
discover_agents() {
    mapfile -t agents < <(
        find "$SCRIPT_DIR/config/agents" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null \
        | LC_COLLATE=C sort
    )

    if [ ${#agents[@]} -eq 0 ]; then
        echo "error: no agents found in config/agents/" >&2
        exit 1
    fi
}

# Check if agent image is built
agent_is_built() {
    local agent="$1"
    podman image exists "agent-session-${agent}:latest" 2>/dev/null
}

# Get agent display name with build status
agent_display() {
    local agent="$1"
    local name="${agent^}"  # Capitalize first letter
    if agent_is_built "$agent"; then
        echo "$name (ready)"
    else
        echo "$name (not built)"
    fi
}

# Show interactive agent selection menu
# Sets global AGENT_TYPE variable based on user selection
select_agent_interactive() {
    discover_agents

    # Skip menu if only one agent
    if [ ${#agents[@]} -eq 1 ]; then
        AGENT_TYPE="${agents[0]}"
        return
    fi

    echo "Available agents:"
    local i=1
    for agent in "${agents[@]}"; do
        echo "  $i. $(agent_display "$agent")"
        ((i++))
    done
    echo ""

    PS3="Select agent (default: ${agents[0]}): "
    select choice in "${agents[@]}"; do
        if [[ -z "$REPLY" ]]; then
            # Empty input = default (first in list)
            AGENT_TYPE="${agents[0]}"
            break
        elif [[ -n "$choice" ]]; then
            AGENT_TYPE="$choice"
            break
        else
            echo "Invalid selection. Enter a number 1-${#agents[@]} or press Enter for default."
        fi
    done
}

# Validate config file format - reject command substitution
validate_config() {
    local config_file="$1"

    # Check file exists and is readable
    if [[ ! -f "$config_file" ]] || [[ ! -r "$config_file" ]]; then
        echo "error: config file not found or not readable: $config_file" >&2
        return 1
    fi

    # Reject command substitution which would execute during sourcing
    if grep -qE '`|\$\(' "$config_file"; then
        echo "error: config contains command substitution (\$() or backticks)" >&2
        echo "config files may only contain KEY=value pairs and variable expansion (\$VAR)" >&2
        return 1
    fi

    return 0
}

# Prompt to build agent if image doesn't exist
ensure_agent_built() {
    local agent="$1"
    local image="agent-session-${agent}:latest"

    if ! podman image exists "$image" 2>/dev/null; then
        echo ""
        read -p "Image not built. Build now? [y/N] " answer
        answer="${answer:-N}"
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            echo "Building ${agent}..."
            "$SCRIPT_DIR/scripts/build.sh" "$agent" || {
                echo "error: build failed" >&2
                exit 1
            }
        else
            echo "Cannot start session without built image."
            exit 1
        fi
    fi
}

# Load agent config with XDG-style layering
load_agent_config() {
    local agent="$1"
    local config_home="${XDG_CONFIG_HOME:-$HOME/.config}"
    local user_config="$config_home/agent-session/agents/$agent/config.conf"
    local repo_config="$SCRIPT_DIR/config/agents/$agent/config.conf"

    # Load repo default first (must exist)
    if [[ ! -f "$repo_config" ]]; then
        echo "error: no default config found for agent: $agent" >&2
        echo "expected: $repo_config" >&2
        return 1
    fi

    validate_config "$repo_config" || return 1
    source "$repo_config"

    # Override with user config if present
    if [[ -f "$user_config" ]]; then
        validate_config "$user_config" || return 1
        source "$user_config"
    fi

    return 0
}

# Build dynamic agent type pattern for grep
get_agent_pattern() {
    discover_agents
    local pattern=""
    for agent in "${agents[@]}"; do
        if [[ -n "$pattern" ]]; then
            pattern="$pattern|$agent"
        else
            pattern="$agent"
        fi
    done
    echo "^($pattern)-"
}

# Find container by session name (searches all agent types)
find_container() {
    local session_name="$1"
    local pattern
    pattern=$(get_agent_pattern)

    local container
    container=$(podman ps -a --format "{{.Names}}" | grep -E "${pattern}${session_name}$" | head -1) || true

    if [[ -z "$container" ]]; then
        echo "error: session '$session_name' not found" >&2
        echo "Use 'agent-session ls' to see available sessions." >&2
        return 1
    fi

    echo "$container"
}

# Check if container is running
container_is_running() {
    local container="$1"
    podman ps --format "{{.Names}}" | grep -q "^${container}$"
}

# Helper to attach or create zellij session
# After zellij exits: if session still exists (detach), return to host; if gone (quit), drop to shell
attach_zellij() {
    # Strip ANSI color codes when checking for existing sessions
    if podman exec "$CONTAINER_NAME" zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q "^$SESSION_NAME "; then
        podman exec -it "$CONTAINER_NAME" bash -c "zellij attach '$SESSION_NAME'; zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q '^$SESSION_NAME ' || exec $AGENT_SHELL"
    else
        # Start new session with agent wrapper as the shell (runs agent, then drops to configured shell)
        podman exec -it -e SHELL=/home/agent/.local/bin/${AGENT_NAME}-session -e AGENT_LAUNCH_CMD="$AGENT_LAUNCH_CMD" "$CONTAINER_NAME" bash -c "zellij -s '$SESSION_NAME'; zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q '^$SESSION_NAME ' || exec $AGENT_SHELL"
    fi
}

# =============================================================================
# Commands
# =============================================================================

cmd_start() {
    local AGENT_TYPE="claude"
    local AGENT_SPECIFIED="false"
    local SESSION_NAME="default"
    local PATHS=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_start_help
                exit 0
                ;;
            -a|--agent)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    echo "error: -a/--agent requires an agent name" >&2
                    echo >&2
                    show_start_help >&2
                    exit 1
                fi
                AGENT_TYPE="$2"
                AGENT_SPECIFIED="true"
                shift 2
                ;;
            -n|--name)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    echo "error: -n/--name requires a session name" >&2
                    echo >&2
                    show_start_help >&2
                    exit 1
                fi
                SESSION_NAME="$2"
                shift 2
                ;;
            -*)
                echo "error: unknown option: $1" >&2
                echo >&2
                show_start_help >&2
                exit 1
                ;;
            *)
                PATHS+=("$1")
                shift
                ;;
        esac
    done

    # If no agent specified via flag, show interactive menu
    if [[ "$AGENT_SPECIFIED" != "true" ]]; then
        select_agent_interactive
    fi

    # Load agent config (uses AGENT_TYPE set by flag or menu)
    load_agent_config "$AGENT_TYPE" || exit 1

    # Ensure image is built
    ensure_agent_built "$AGENT_TYPE"

    CONTAINER_NAME="${AGENT_TYPE}-${SESSION_NAME}"
    IMAGE_NAME="agent-session-${AGENT_TYPE}:latest"

    # Check if container exists and is running
    if podman ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
        echo "Attaching to '$SESSION_NAME'..."
        attach_zellij
        exit 0
    fi

    # Check if container exists but stopped
    if podman ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
        echo "Starting '$SESSION_NAME'..."
        podman start "$CONTAINER_NAME"
        sleep 1  # Wait for container to be ready
        attach_zellij
        exit 0
    fi

    # Need paths to create a new session
    if [ ${#PATHS[@]} -eq 0 ]; then
        PATHS=("$(pwd)")
    fi

    # Validate paths exist
    for path in "${PATHS[@]}"; do
        if [[ ! -e "$path" ]]; then
            echo "error: path does not exist: $path" >&2
            exit 1
        fi
    done

    # Build mount arguments from provided paths
    MOUNTS=""
    FIRST_DIR=""
    for path in "${PATHS[@]}"; do
        abs_path=$(realpath "$path")
        dir_name=$(basename "$abs_path")
        container_path="/workspace/$dir_name"
        MOUNTS="$MOUNTS -v $abs_path:$container_path:Z"
        [[ -z "$FIRST_DIR" ]] && FIRST_DIR="$container_path"
    done

    # Mount kob repo at same path so symlinks resolve correctly
    KOB_MOUNT=""
    if [[ -n "${AGENT_SESSION_KOB:-}" ]]; then
        if [[ -d "$AGENT_SESSION_KOB" ]]; then
            KOB_MOUNT="-v $AGENT_SESSION_KOB:$AGENT_SESSION_KOB:Z"
        else
            echo "warning: AGENT_SESSION_KOB path does not exist: $AGENT_SESSION_KOB" >&2
        fi
    fi

    # Build extra mounts from AGENT_SESSION_MOUNTS env var
    EXTRA_MOUNTS=""
    if [[ -n "${AGENT_SESSION_MOUNTS:-}" ]]; then
        IFS=':' read -ra MOUNT_PATHS <<< "$AGENT_SESSION_MOUNTS"
        for mount_path in "${MOUNT_PATHS[@]}"; do
            if [[ -e "$mount_path" ]]; then
                EXTRA_MOUNTS="$EXTRA_MOUNTS -v $mount_path:$mount_path:ro"
            else
                echo "warning: AGENT_SESSION_MOUNTS path does not exist: $mount_path" >&2
            fi
        done
    fi

    # Build optional mounts - only include if directory exists
    OPTIONAL_MOUNTS=""
    [[ -d "$HOME/.claude" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.claude:/config/.claude:Z"
    [[ -d "$HOME/.local/share/claude" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.local/share/claude:/home/agent/.local/share/claude:Z"
    [[ -d "$HOME/.config/opencode" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.config/opencode:/config/opencode:Z"
    [[ -d "$HOME/.local/share/opencode" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.local/share/opencode:/home/agent/.local/share/opencode:Z"
    [[ -d "$HOME/.config/zellij" ]] && OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v $HOME/.config/zellij:/config/zellij:ro"

    # Mount bundled OpenCode MCP config if no user config exists
    if [[ "$AGENT_TYPE" == "opencode" ]] && [[ ! -d "$HOME/.config/opencode" ]] && [[ -f "$SCRIPT_DIR/config/agents/opencode/opencode.json" ]]; then
        mkdir -p /tmp/opencode-config
        cp "$SCRIPT_DIR/config/agents/opencode/opencode.json" /tmp/opencode-config/
        OPTIONAL_MOUNTS="$OPTIONAL_MOUNTS -v /tmp/opencode-config:/config/opencode:Z"
    fi

    echo "Starting new session '$SESSION_NAME'..."
    podman run -d \
        --name "$CONTAINER_NAME" \
        --userns=keep-id \
        --workdir "$FIRST_DIR" \
        -v "$HOME/.claude.json:/home/agent/.claude.json:Z" \
        $OPTIONAL_MOUNTS \
        $EXTRA_MOUNTS \
        $MOUNTS \
        $KOB_MOUNT \
        "$IMAGE_NAME" \
        bash -c 'trap "exit 0" TERM; while :; do sleep 1; done'

    # Wait for container to be ready
    sleep 1
    attach_zellij
}

cmd_stop() {
    local session_name="default"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_stop_help
                exit 0
                ;;
            -*)
                echo "error: unknown option: $1" >&2
                echo >&2
                show_stop_help >&2
                exit 1
                ;;
            *)
                session_name="$1"
                shift
                ;;
        esac
    done

    local container
    container=$(find_container "$session_name") || exit 1

    # Stop is idempotent - stopping already-stopped succeeds silently
    podman stop "$container" >/dev/null 2>&1 || true
    echo "Stopped: $session_name"
}

cmd_restart() {
    local session_name="default"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_restart_help
                exit 0
                ;;
            -*)
                echo "error: unknown option: $1" >&2
                echo >&2
                show_restart_help >&2
                exit 1
                ;;
            *)
                session_name="$1"
                shift
                ;;
        esac
    done

    local container
    container=$(find_container "$session_name") || exit 1

    # Extract agent type from container name
    local agent_type="${container%%-*}"

    # Load agent config for attach_zellij
    load_agent_config "$agent_type" || exit 1

    # Set globals needed by attach_zellij
    CONTAINER_NAME="$container"
    SESSION_NAME="$session_name"

    # Check if already running
    if container_is_running "$container"; then
        echo "Session '$session_name' is already running. Attaching..."
    else
        echo "Starting '$session_name'..."
        podman start "$container" >/dev/null
        sleep 1  # Wait for container to be ready
    fi

    attach_zellij
}

cmd_ls() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_ls_help
                exit 0
                ;;
            -*)
                echo "error: unknown option: $1" >&2
                echo >&2
                show_ls_help >&2
                exit 1
                ;;
            *)
                echo "error: unexpected argument: $1" >&2
                echo >&2
                show_ls_help >&2
                exit 1
                ;;
        esac
    done

    local pattern
    pattern=$(get_agent_pattern)

    local containers
    containers=$(podman ps -a --format "{{.Names}}|{{.Status}}" | grep -E "$pattern" || true)

    if [[ -z "$containers" ]]; then
        echo "No sessions found."
        return 0
    fi

    # Header
    printf "%-20s %-12s %s\n" "NAME" "AGENT" "STATUS"

    while IFS='|' read -r name status; do
        # Extract agent type and session name from container name
        local agent_type session_name
        agent_type="${name%%-*}"
        session_name="${name#*-}"

        # Determine running/stopped from status string
        local state color
        if [[ "$status" == Up* ]]; then
            state="running"
            color="$COLOR_GREEN"
        else
            state="stopped"
            color="$COLOR_RED"
        fi

        printf "%-20s %-12s ${color}%s${COLOR_RESET}\n" "$session_name" "$agent_type" "$state"
    done <<< "$containers"
}

cmd_rm() {
    local force=false
    local session_name="default"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_rm_help
                exit 0
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -*)
                echo "error: unknown option: $1" >&2
                echo >&2
                show_rm_help >&2
                exit 1
                ;;
            *)
                session_name="$1"
                shift
                ;;
        esac
    done

    local container
    container=$(find_container "$session_name") || exit 1

    # Check if running - cannot rm running container
    if container_is_running "$container"; then
        echo "error: cannot remove running session '$session_name'" >&2
        echo "Stop it first with: agent-session stop $session_name" >&2
        exit 1
    fi

    if [[ "$force" != true ]]; then
        read -p "Remove session '$session_name'? [y/N] " -r
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    podman rm "$container" >/dev/null
    echo "Removed: $session_name"
}

# =============================================================================
# Main dispatch
# =============================================================================

main() {
    case "${1:-}" in
        start)
            shift
            cmd_start "$@"
            ;;
        stop)
            shift
            cmd_stop "$@"
            ;;
        restart)
            shift
            cmd_restart "$@"
            ;;
        ls|list)
            shift
            cmd_ls "$@"
            ;;
        rm|remove)
            shift
            cmd_rm "$@"
            ;;
        -h|--help|help)
            show_help
            exit 0
            ;;
        "")
            show_help
            exit 0
            ;;
        *)
            echo "error: unknown command: $1" >&2
            echo "Run 'agent-session --help' for usage." >&2
            exit 1
            ;;
    esac
}

main "$@"
